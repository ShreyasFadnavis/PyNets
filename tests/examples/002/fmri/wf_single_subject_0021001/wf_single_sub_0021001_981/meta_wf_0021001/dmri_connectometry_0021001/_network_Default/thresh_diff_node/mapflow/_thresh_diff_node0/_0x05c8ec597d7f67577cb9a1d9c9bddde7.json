[('ID', '0021001'), ('atlas', 'DesikanKlein2012'), ('atlas_mni', ('/Users/derekpisner/Applications/PyNets/tests/examples/002/dmri/reg_dmri/anat_reg/DesikanKlein2012_t1w_mni.nii.gz', '47092c4bdd075aa61db0731f7bd8a8a5')), ('binary', False), ('conn_matrix', matrix([[ 0.,  0.,  0., ...,  0.,  0.,  0.],
        [ 0.,  0., 51., ...,  0.,  0.,  0.],
        [ 0., 51.,  0., ...,  0.,  0.,  0.],
        ...,
        [ 0.,  0.,  0., ...,  0.,  3.,  3.],
        [ 0.,  0.,  0., ...,  3.,  0.,  6.],
        [ 0.,  0.,  0., ...,  3.,  6.,  0.]])), ('conn_model', 'csd'), ('coords', ('41.4603671909', '-7.7177768031', '44.1708753681')), ('dens_thresh', True), ('dir_path', '/Users/derekpisner/Applications/PyNets/tests/examples/002/dmri/DesikanKlein2012'), ('disp_filt', False), ('function_str', 'def thresh_struct(dens_thresh, thr, conn_matrix, conn_model, network, ID, dir_path, roi, node_size, min_span_tree,\n                  disp_filt, parc, prune, atlas, uatlas, labels, coords, norm, binary,\n                  target_samples, track_type, atlas_mni, streams):\n    """\n    Threshold a structural connectivity matrix using any of a variety of methods.\n\n    Parameters\n    ----------\n    dens_thresh : bool\n        Indicates whether a target graph density is to be used as the basis for\n        thresholding.\n    thr : float\n        A value, between 0 and 1, to threshold the graph using any variety of methods\n        triggered through other options.\n    conn_matrix : array\n        Adjacency matrix stored as an m x n array of nodes and edges.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    ID : str\n        A subject id or other unique identifier.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s.\n    min_span_tree : bool\n        Indicates whether local thresholding from the Minimum Spanning Tree\n        should be used.\n    disp_filt : bool\n        Indicates whether local thresholding using a disparity filter and\n        \'backbone network\' should be used.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to ROI nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    target_samples : int\n        Total number of streamline samples specified to generate streams.\n    track_type : str\n        Tracking algorithm used (e.g. \'local\' or \'particle\').\n    atlas_mni : str\n        File path to atlas parcellation Nifti1Image in T1w-warped MNI space.\n    streams : str\n        File path to save streamline array sequence in .trk format.\n\n    Returns\n    -------\n    conn_matrix_thr : array\n        Weighted, thresholded, NxN matrix.\n    edge_threshold : str\n        The string percentage representation of thr.\n    est_path : str\n        File path to the thresholded graph, conn_matrix_thr, saved as a numpy array in .npy format.\n    thr : float\n        The value, between 0 and 1, used to threshold the graph using any variety of methods\n        triggered through other options.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    ID : str\n        A subject id or other unique identifier.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to ROI nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    target_samples : int\n        Total number of streamline samples specified to generate streams.\n    track_type : str\n        Tracking algorithm used (e.g. \'local\' or \'particle\').\n    atlas_mni : str\n        File path to atlas parcellation Nifti1Image in T1w-warped MNI space.\n    streams : str\n        File path to save streamline array sequence in .trk format.\n    """\n    import warnings\n    warnings.filterwarnings("ignore")\n    from pynets import utils, thresholding\n\n    thr_perc = 100 * float(thr)\n    edge_threshold = "%s%s" % (str(thr_perc), \'%\')\n    if parc is True:\n        node_size = \'parc\'\n\n    if np.count_nonzero(conn_matrix) == 0:\n        raise ValueError(\'ERROR: Raw connectivity matrix contains only zeros.\')\n\n    # Save unthresholded\n    unthr_path = utils.create_unthr_path(ID, network, conn_model, roi, dir_path)\n    utils.save_mat(conn_matrix, unthr_path)\n\n    if min_span_tree is True:\n        print(\'Using local thresholding option with the Minimum Spanning Tree (MST)...\\n\')\n        if dens_thresh is False:\n            thr_type = \'MSTprop\'\n            conn_matrix_thr = thresholding.local_thresholding_prop(conn_matrix, thr)\n        else:\n            thr_type = \'MSTdens\'\n            conn_matrix_thr = thresholding.local_thresholding_dens(conn_matrix, thr)\n    elif disp_filt is True:\n        thr_type = \'DISP_alpha\'\n        G1 = thresholding.disparity_filter(nx.from_numpy_array(conn_matrix))\n        # G2 = nx.Graph([(u, v, d) for u, v, d in G1.edges(data=True) if d[\'alpha\'] < thr])\n        print(\'Computing edge disparity significance with alpha = %s\' % thr)\n        print(\'Filtered graph: nodes = %s, edges = %s\' % (G1.number_of_nodes(), G1.number_of_edges()))\n        # print(\'Backbone graph: nodes = %s, edges = %s\' % (G2.number_of_nodes(), G2.number_of_edges()))\n        # print(G2.edges(data=True))\n        conn_matrix_thr = nx.to_numpy_array(G1)\n    else:\n        if dens_thresh is False:\n            thr_type = \'prop\'\n            print("%s%.2f%s" % (\'\\nThresholding proportionally at: \', thr_perc, \'% ...\\n\'))\n            conn_matrix_thr = thresholding.threshold_proportional(conn_matrix, float(thr))\n        else:\n            thr_type = \'dens\'\n            print("%s%.2f%s" % (\'\\nThresholding to achieve density of: \', thr_perc, \'% ...\\n\'))\n            conn_matrix_thr = thresholding.density_thresholding(conn_matrix, float(thr))\n\n    if not nx.is_connected(nx.from_numpy_matrix(conn_matrix_thr)):\n        print(\'Warning: Fragmented graph\')\n\n    # Save thresholded mat\n    est_path = utils.create_est_path_diff(ID, network, conn_model, thr, roi, dir_path, node_size, target_samples,\n                                          track_type, thr_type, parc)\n\n    utils.save_mat(conn_matrix_thr, est_path)\n\n    return conn_matrix_thr, edge_threshold, est_path, thr, node_size, network, conn_model, roi, prune, ID, dir_path, atlas, uatlas, labels, coords, norm, binary, target_samples, track_type, atlas_mni, streams\n'), ('labels', 'nan'), ('min_span_tree', False), ('network', None), ('node_size', None), ('norm', 0), ('parc', True), ('prune', '1'), ('roi', None), ('streams', ('/Users/derekpisner/Applications/PyNets/tests/examples/002/dmri/DesikanKlein2012/streamlines_mni_csd_100000_Nonemm_curv[60_30_10]_step[0.2_0.3_0.4_0.5]_warped.trk', '719477a611d2dee93c35fa75db9b1669')), ('target_samples', '100000'), ('thr', '0.15'), ('track_type', 'particle'), ('uatlas', ('/Users/derekpisner/Applications/PyNets/pynets/atlases/DesikanKlein2012.nii.gz', '8b05327694ff8612e04249dae9d49822'))]