[('ID', '002'), ('atlas', 'coords_dosenbach_2010'), ('binary', False), ('c_boot', 0), ('conn_model', 'partcorr'), ('coords', [(18, -81, -33), (-21, -79, -33), (-6, -79, -33), (33, -73, -30), (-34, -67, -29), (32, -61, -31), (-25, -60, -34), (-37, -54, -37), (21, -64, -22), (-34, -57, -24), (-24, -54, -21), (-28, -44, -25), (5, -75, -11), (14, -75, -21), (-11, -72, -14), (1, -66, -24), (-16, -64, -21), (-6, -60, -15), (-2, 30, 27), (-52, -63, 15), (27, 49, 26), (-41, -47, 29), (-36, 18, 2), (38, 21, -1), (11, -24, 2), (-20, 6, 7), (14, 6, 7), (-6, 17, 34), (9, 20, 34), (54, -31, -18), (0, 15, 45), (-30, -14, 1), (32, -12, 2), (37, -2, -3), (-55, -44, 30), (58, -41, 20), (-4, -31, -4), (-30, -28, 9), (8, -40, 50), (42, -46, 21), (-59, -47, 11), (43, -43, 8), (51, -30, 5), (-12, -12, 6), (11, -12, 6), (-12, -3, 13), (-48, 6, 1), (-46, 10, 14), (51, 23, 8), (34, 32, 7), (9, 39, 20), (-36, -69, 40), (-25, 51, 27), (-48, -63, 35), (51, -59, 34), (28, -37, -15), (-61, -41, -2), (-59, -25, -15), (52, -15, -13), (0, 51, 32), (-42, -76, 26), (-2, -75, 32), (-9, -72, 41), (45, -72, 29), (-28, -42, -11), (-11, -58, 17), (10, -55, 17), (-5, -52, 17), (-5, -43, 25), (-8, -41, 3), (1, -26, 31), (11, -68, 42), (-6, -56, 29), (5, -50, 33), (9, -43, 25), (-3, -38, 45), (-16, 29, 54), (23, 33, 47), (46, 39, -15), (8, 42, -5), (-11, 45, 17), (-6, 50, -1), (9, 51, 16), (6, 64, 3), (-1, 28, 40), (44, -52, 47), (-53, -50, 39), (-48, -47, 49), (54, -44, 43), (-41, -40, 42), (32, -59, 41), (-32, -58, 46), (29, 57, 18), (-29, 57, 10), (-42, 7, 36), (44, 8, 34), (40, 17, 40), (-44, 27, 33), (46, 28, 31), (40, 36, 29), (-35, -46, 48), (-52, 28, 17), (-43, 47, 2), (42, 48, -3), (39, 42, 16), (20, -78, -2), (15, -77, 32), (-16, -76, 33), (9, -76, 14), (-29, -75, 28), (29, -73, 29), (39, -71, 13), (17, -68, 20), (19, -66, -1), (-44, -63, -7), (-34, -60, -5), (36, -60, -8), (-18, -50, 1), (-4, -94, 12), (13, -91, 2), (27, -91, 2), (-29, -88, 8), (-37, -83, -2), (29, -81, 14), (33, -81, -2), (-5, -80, 9), (46, -62, 5), (0, -1, 52), (60, 8, 34), (53, -3, 32), (58, 11, 14), (33, -12, 16), (-36, -12, 15), (-42, -3, 11), (-24, -30, 64), (18, -27, 62), (-38, -27, 60), (41, -23, 55), (-55, -22, 38), (46, -20, 45), (-47, -18, 50), (-38, -15, 59), (-47, -12, 36), (-26, -8, 54), (42, -24, 17), (-41, -31, 48), (10, 5, 51), (-54, -22, 22), (44, -11, 38), (-54, -9, 23), (46, -8, 24), (-44, -6, 49), (58, -3, 17), (34, -39, 65), (-41, -37, 16), (-53, -37, 13), (-54, -22, 9), (59, -13, 8), (43, 1, 12), (-55, 7, 23)]), ('dens_thresh', False), ('dir_path', '/Users/derekpisner/Applications/PyNets/tests/examples/002/fmri/coords_dosenbach_2010'), ('disp_filt', False), ('function_str', 'def get_conn_matrix(time_series, conn_model, dir_path, node_size, smooth, dens_thresh, network, ID, roi, min_span_tree,\n                    disp_filt, parc, prune, atlas, uatlas, labels, coords, c_boot, norm, binary,\n                    hpass):\n    """\n    Computes a functional connectivity matrix based on a node-extracted time-series array.\n    Includes a library of routines across Nilearn, scikit-learn, and skggm packages, among others.\n\n    Parameters\n    ----------\n    time_series : array\n        2D m x n array consisting of the time-series signal for each ROI node where m = number of scans and\n        n = number of ROI\'s.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s.\n    smooth : int\n        Smoothing width (mm fwhm) to apply to time-series when extracting signal from ROI\'s.\n    dens_thresh : bool\n        Indicates whether a target graph density is to be used as the basis for\n        thresholding.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    ID : str\n        A subject id or other unique identifier.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    min_span_tree : bool\n        Indicates whether local thresholding from the Minimum Spanning Tree\n        should be used.\n    disp_filt : bool\n        Indicates whether local thresholding using a disparity filter and\n        \'backbone network\' should be used.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to ROI nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    c_boot : int\n        Number of bootstraps if user specified circular-block bootstrapped resampling of the node-extracted time-series.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    hpass : bool\n        High-pass filter values (Hz) to apply to node-extracted time-series.\n\n    Returns\n    -------\n    conn_matrix : array\n        Adjacency matrix stored as an m x n array of nodes and edges.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s for tracking.\n    smooth : int\n        Smoothing width (mm fwhm) to apply to time-series when extracting signal from ROI\'s.\n    dens_thresh : bool\n        Indicates whether a target graph density is to be used as the basis for\n        thresholding.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    ID : str\n        A subject id or other unique identifier.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    min_span_tree : bool\n        Indicates whether local thresholding from the Minimum Spanning Tree\n        should be used.\n    disp_filt : bool\n        Indicates whether local thresholding using a disparity filter and\n        \'backbone network\' should be used.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to graph nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    c_boot : int\n        Number of bootstraps if user specified circular-block bootstrapped resampling of the node-extracted time-series.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    hpass : bool\n        High-pass filter values (Hz) to apply to node-extracted time-series.\n    """\n    import warnings\n    warnings.filterwarnings("ignore")\n    from nilearn.connectome import ConnectivityMeasure\n    from sklearn.covariance import GraphicalLassoCV\n\n    conn_matrix = None\n    if conn_model == \'corr\' or conn_model == \'cor\' or conn_model == \'correlation\':\n        # credit: nilearn\n        print(\'\\nComputing correlation matrix...\\n\')\n        conn_measure = ConnectivityMeasure(kind=\'correlation\')\n        conn_matrix = conn_measure.fit_transform([time_series])[0]\n    elif conn_model == \'partcorr\' or conn_model == \'parcorr\' or conn_model == \'partialcorrelation\':\n        # credit: nilearn\n        print(\'\\nComputing partial correlation matrix...\\n\')\n        conn_measure = ConnectivityMeasure(kind=\'partial correlation\')\n        conn_matrix = conn_measure.fit_transform([time_series])[0]\n    elif conn_model == \'cov\' or conn_model == \'covariance\' or conn_model == \'covar\' or conn_model == \'sps\' or conn_model == \'sparse\' or conn_model == \'precision\':\n        # Fit estimator to matrix to get sparse matrix\n        estimator_shrunk = None\n        estimator = GraphicalLassoCV(cv=5)\n        try:\n            print(\'\\nComputing covariance...\\n\')\n            estimator.fit(time_series)\n        except:\n            print(\'Unstable Lasso estimation--Attempting to re-run by first applying shrinkage...\')\n            try:\n                from sklearn.covariance import GraphicalLasso, empirical_covariance, shrunk_covariance\n                emp_cov = empirical_covariance(time_series)\n                for i in np.arange(0.8, 0.99, 0.01):\n                    shrunk_cov = shrunk_covariance(emp_cov, shrinkage=i)\n                    alphaRange = 10.0 ** np.arange(-8, 0)\n                    for alpha in alphaRange:\n                        try:\n                            estimator_shrunk = GraphicalLasso(alpha)\n                            estimator_shrunk.fit(shrunk_cov)\n                            print("Retrying covariance matrix estimate with alpha=%s" % alpha)\n                            if estimator_shrunk is None:\n                                pass\n                            else:\n                                break\n                        except:\n                            print("Covariance estimation failed with shrinkage at alpha=%s" % alpha)\n                            continue\n            except ValueError:\n                print(\'Unstable Lasso estimation! Shrinkage failed. A different connectivity model may be needed.\')\n        if estimator is None and estimator_shrunk is None:\n            raise RuntimeError(\'\\nERROR: Covariance estimation failed.\')\n        if conn_model == \'sps\' or conn_model == \'sparse\' or conn_model == \'precision\':\n            if estimator_shrunk is None:\n                print(\'\\nFetching precision matrix from covariance estimator...\\n\')\n                conn_matrix = -estimator.precision_\n            else:\n                print(\'\\nFetching shrunk precision matrix from covariance estimator...\\n\')\n                conn_matrix = -estimator_shrunk.precision_\n        elif conn_model == \'cov\' or conn_model == \'covariance\' or conn_model == \'covar\':\n            if estimator_shrunk is None:\n                print(\'\\nFetching covariance matrix from covariance estimator...\\n\')\n                conn_matrix = estimator.covariance_\n            else:\n                conn_matrix = estimator_shrunk.covariance_\n    elif conn_model == \'QuicGraphicalLasso\':\n        try:\n            from inverse_covariance import QuicGraphicalLasso\n        except ImportError:\n            print(\'Cannot run QuicGraphLasso. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLasso\n        # credit: skggm\n        model = QuicGraphicalLasso(\n            init_method=\'cov\',\n            lam=0.5,\n            mode=\'default\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLasso precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'QuicGraphLassoCV\':\n        try:\n            from inverse_covariance import QuicGraphicalLassoCV\n        except ImportError:\n            print(\'Cannot run QuicGraphLassoCV. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLassoCV\n        # credit: skggm\n        model = QuicGraphicalLassoCV(\n            init_method=\'cov\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLassoCV precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'QuicGraphicalLassoEBIC\':\n        try:\n            from inverse_covariance import QuicGraphicalLassoEBIC\n        except ImportError:\n            print(\'Cannot run QuicGraphLassoEBIC. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLassoEBIC\n        # credit: skggm\n        model = QuicGraphicalLassoEBIC(\n            init_method=\'cov\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLassoEBIC precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'AdaptiveQuicGraphLasso\':\n        try:\n            from inverse_covariance import AdaptiveQuicGraphicalLasso, QuicGraphicalLassoEBIC\n        except ImportError:\n            print(\'Cannot run AdaptiveGraphLasso. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via\n        # AdaptiveGraphLasso + QuicGraphLassoEBIC + method=\'binary\'\n        # credit: skggm\n        model = AdaptiveQuicGraphicalLasso(\n            estimator=QuicGraphicalLassoEBIC(\n                init_method=\'cov\',\n            ),\n            method=\'binary\',\n        )\n        print(\'\\nCalculating AdaptiveQuicGraphLasso precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.estimator_.precision_\n    else:\n        raise ValueError(\'\\nERROR! No connectivity model specified at runtime. Select a valid estimator using the \'\n                         \'-mod flag.\')\n\n    if conn_matrix.shape < (2, 2):\n        raise RuntimeError(\'\\nERROR! Matrix estimation selection yielded an empty or 1-dimensional graph. \'\n                           \'Check time-series for errors or try using a different atlas\')\n\n    coords = np.array(coords)\n    labels = np.array(labels)\n    return conn_matrix, conn_model, dir_path, node_size, smooth, dens_thresh, network, ID, roi, min_span_tree, disp_filt, parc, prune, atlas, uatlas, labels, coords, c_boot, norm, binary, hpass\n'), ('hpass', None), ('labels', ["inf cerebellum' 155", "inf cerebellum' 150", "inf cerebellum' 151", "inf cerebellum' 140", "inf cerebellum' 131", "inf cerebellum' 122", "inf cerebellum' 121", "inf cerebellum' 110", "lat cerebellum' 128", "lat cerebellum' 113", "lat cerebellum' 109", "lat cerebellum' 98", "med cerebellum' 143", "med cerebellum' 144", "med cerebellum' 138", "med cerebellum' 130", "med cerebellum' 127", "med cerebellum' 120", "ACC' 19", "TPJ' 125", "aPFC' 8", "angular gyrus' 102", "ant insula' 28", "ant insula' 26", "asal ganglia' 71", "asal ganglia' 38", "asal ganglia' 39", "asal ganglia' 30", "dACC' 27", "fusiform' 81", "mFC' 31", "mid insula' 61", "mid insula' 59", "mid insula' 44", "parietal' 97", "parietal' 89", "post cingulate' 80", "post insula' 76", "precuneus' 87", "sup temporal' 100", "temporal' 103", "temporal' 95", "temporal' 78", "thalamus' 57", "thalamus' 58", "thalamus' 47", "vFC' 40", "vFC' 33", "vFC' 25", "vPFC' 18", "ACC' 14", "IPS' 134", "aPFC' 5", "angular gyrus' 124", "angular gyrus' 117", "fusiform' 84", "inf temporal' 91", "inf temporal' 72", "inf temporal' 63", "mPFC' 4", "occipital' 146", "occipital' 141", "occipital' 136", "occipital' 137", "occipital' 92", "post cingulate' 115", "post cingulate' 111", "post cingulate' 108", "post cingulate' 93", "post cingulate' 90", "post cingulate' 73", "precuneus' 132", "precuneus' 112", "precuneus' 105", "precuneus' 94", "precuneus' 85", "sup frontal' 20", "sup frontal' 17", "vlPFC' 15", "vmPFC' 13", "vmPFC' 11", "vmPFC' 7", "vmPFC' 6", "vmPFC' 1", "ACC' 21", "IPL' 107", "IPL' 104", "IPL' 101", "IPL' 96", "IPL' 88", "IPS' 116", "IPS' 114", "aPFC' 2", "aPFC' 3", "dFC' 36", "dFC' 34", "dFC' 29", "dlPFC' 24", "dlPFC' 22", "dlPFC' 16", "post parietal' 99", "vPFC' 23", "vent aPFC' 10", "vent aPFC' 9", "vlPFC' 12", "occipital' 149", "occipital' 148", "occipital' 145", "occipital' 147", "occipital' 142", "occipital' 139", "occipital' 135", "occipital' 133", "occipital' 129", "occipital' 126", "occipital' 118", "occipital' 119", "occipital' 106", "post occipital' 160", "post occipital' 158", "post occipital' 159", "post occipital' 157", "post occipital' 156", "post occipital' 153", "post occipital' 154", "post occipital' 152", "temporal' 123", "SMA' 43", "dFC' 35", "frontal' 45", "frontal' 32", "mid insula' 55", "mid insula' 56", "mid insula' 48", "parietal' 77", "parietal' 74", "parietal' 75", "parietal' 69", "parietal' 66", "parietal' 65", "parietal' 64", "parietal' 62", "parietal' 54", "parietal' 50", "post insula' 70", "post parietal' 79", "pre-SMA' 41", "precentral gyrus' 67", "precentral gyrus' 53", "precentral gyrus' 52", "precentral gyrus' 51", "precentral gyrus' 49", "precentral gyrus' 46", "sup parietal' 86", "temporal' 82", "temporal' 83", "temporal' 68", "temporal' 60", "vFC' 42", "vFC' 37"]), ('min_span_tree', False), ('network', None), ('node_size', 4), ('norm', 0), ('parc', False), ('prune', 2), ('roi', None), ('smooth', 0), ('time_series', array([[ 0.47936726,  0.21562016,  0.9098474 , ...,  1.4557384 ,
         0.67859733,  2.1469617 ],
       [-0.44362283, -0.56842905, -0.26336044, ...,  0.35957202,
        -0.7581002 , -0.5021044 ],
       [ 1.7974648 ,  1.2960566 , -0.7035486 , ..., -2.088116  ,
        -0.05854088, -0.5470562 ],
       ...,
       [ 0.5018247 ,  0.13410044,  2.826761  , ..., -0.35812253,
        -1.3799503 , -0.60179144],
       [ 0.5489054 ,  0.8050069 ,  0.64535046, ..., -0.13348271,
         2.1412947 ,  0.09506529],
       [ 1.5009807 ,  2.0156004 , -0.30856156, ..., -1.5216969 ,
         0.8530325 , -0.74819744]], dtype=float32)), ('uatlas', None)]