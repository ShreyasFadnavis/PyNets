[
    [
        "atlas",
        "coords_dosenbach_2010"
    ],
    [
        "function_str",
        "def fetch_nodes_and_labels(atlas, uatlas, ref_txt, parc, in_file, use_AAL_naming, clustering=False):\n    \"\"\"\n    General API for fetching, identifying, and defining atlas nodes based on coordinates and/or labels.\n\n    Parameters\n    ----------\n    atlas : str\n        Name of a Nilearn-hosted coordinate or parcellation/label-based atlas supported for fetching.\n        See Nilearn's datasets.atlas module for more detailed reference.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    ref_txt : str\n        Path to an atlas reference .txt file that maps labels to intensities corresponding to uatlas.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    in_file : str\n        File path to Nifti1Image object whose affine will provide sampling reference for fetching.\n    use_AAL_naming : bool\n        Indicates whether to perform Automated-Anatomical Labeling of each coordinate from a list of a voxel\n        coordinates.\n    clustering : bool\n        Indicates whether clustering was performed. Default is False.\n\n    Returns\n    -------\n    labels : list\n        List of string labels corresponding to ROI nodes.\n    coords : list\n        List of (x, y, z) tuples in mm-space corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    atlas_name : str\n        Name of atlas parcellation (can differ slightly from fetch API string).\n    networks_list : list\n        List of RSN's and their associated cooordinates, if predefined uniquely for a given atlas.\n    parcel_list : list\n        List of 3D boolean numpy arrays or binarized Nifti1Images corresponding to ROI masks.\n    par_max : int\n        The maximum label intensity in the parcellation image.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    \"\"\"\n    import warnings\n    warnings.filterwarnings(\"ignore\")\n    from pynets.core import utils, nodemaker\n    import pandas as pd\n    import time\n    from pathlib import Path\n    import os.path as op\n\n    base_path = utils.get_file()\n    # Test if atlas is a nilearn atlas. If so, fetch coords, labels, and/or networks.\n    nilearn_parc_atlases = ['atlas_harvard_oxford', 'atlas_aal', 'atlas_destrieux_2009', 'atlas_talairach_gyrus',\n                            'atlas_talairach_ba', 'atlas_talairach_lobe']\n    nilearn_coords_atlases = ['coords_power_2011', 'coords_dosenbach_2010']\n    nilearn_prob_atlases = ['atlas_msdl', 'atlas_pauli_2017']\n    if uatlas is None and atlas in nilearn_parc_atlases:\n        [labels, networks_list, uatlas] = nodemaker.nilearn_atlas_helper(atlas, parc)\n        if uatlas:\n            if not isinstance(uatlas, str):\n                nib.save(uatlas, \"%s%s%s\" % ('/tmp/', atlas, '.nii.gz'))\n                uatlas = \"%s%s%s\" % ('/tmp/', atlas, '.nii.gz')\n            [coords, _, par_max] = nodemaker.get_names_and_coords_of_parcels(uatlas)\n            if parc is True:\n                parcel_list = nodemaker.gen_img_list(uatlas)\n            else:\n                parcel_list = None\n        else:\n            raise ValueError(\"%s%s%s\" % ('\\nERROR: Atlas file for ', atlas, ' not found!'))\n    elif uatlas is None and parc is False and atlas in nilearn_coords_atlases:\n        print('Fetching coords and labels from nilearn coordinate-based atlas library...')\n        # Fetch nilearn atlas coords\n        [coords, _, networks_list, labels] = nodemaker.fetch_nilearn_atlas_coords(atlas)\n        parcel_list = None\n        par_max = None\n    elif uatlas is None and parc is False and atlas in nilearn_prob_atlases:\n        from nilearn.plotting import find_probabilistic_atlas_cut_coords\n        print('Fetching coords and labels from nilearn probabilistic atlas library...')\n        # Fetch nilearn atlas coords\n        [labels, networks_list, uatlas] = nodemaker.nilearn_atlas_helper(atlas, parc)\n        coords = find_probabilistic_atlas_cut_coords(maps_img=uatlas)\n        if uatlas:\n            if not isinstance(uatlas, str):\n                nib.save(uatlas, \"%s%s%s\" % ('/tmp/', atlas, '.nii.gz'))\n                uatlas = \"%s%s%s\" % ('/tmp/', atlas, '.nii.gz')\n            if parc is True:\n                parcel_list = nodemaker.gen_img_list(uatlas)\n            else:\n                parcel_list = None\n        else:\n            raise ValueError(\"%s%s%s\" % ('\\nERROR: Atlas file for ', atlas, ' not found!'))\n        par_max = None\n    elif uatlas:\n        if clustering is True:\n            while True:\n                if op.isfile(uatlas):\n                    break\n                else:\n                    print('Waiting for atlas file...')\n                    time.sleep(15)\n        atlas = uatlas.split('/')[-1].split('.')[0]\n        try:\n            # Fetch user-specified atlas coords\n            [coords, atlas, par_max] = nodemaker.get_names_and_coords_of_parcels(uatlas)\n            if parc is True:\n                parcel_list = nodemaker.gen_img_list(uatlas)\n            else:\n                parcel_list = None\n            # Describe user atlas coords\n            print(\"%s%s%s%s\" % ('\\n', atlas, ' comes with {0} '.format(par_max), 'parcels\\n'))\n        except ValueError:\n            print('\\n\\nError: Either you have specified the name of a nilearn atlas that does not exist or '\n                  'you have not supplied a 3d atlas parcellation image!\\n\\n')\n            parcel_list = None\n            par_max = None\n            coords = None\n        labels = None\n        networks_list = None\n    else:\n        networks_list = None\n        labels = None\n        parcel_list = None\n        par_max = None\n        coords = None\n\n    # Labels prep\n    if atlas:\n        if labels:\n            pass\n        else:\n            if (ref_txt is not None) and (op.exists(ref_txt)) and (use_AAL_naming is False):\n                dict_df = pd.read_csv(ref_txt, sep=\" \", header=None, names=[\"Index\", \"Region\"])\n                labels = dict_df['Region'].tolist()\n            else:\n                try:\n                    ref_txt = \"%s%s%s%s\" % (str(Path(base_path).parent), '/labelcharts/', atlas, '.txt')\n                    if op.exists(ref_txt) and (use_AAL_naming is False):\n                        try:\n                            dict_df = pd.read_csv(ref_txt, sep=\"\\t\", header=None, names=[\"Index\", \"Region\"])\n                            labels = dict_df['Region'].tolist()\n                        except:\n                            labels = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()\n                    else:\n                        if use_AAL_naming is True:\n                            try:\n                                labels = nodemaker.AAL_naming(coords)\n                            except:\n                                print('AAL reference labeling failed!')\n                                labels = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()\n                        else:\n                            print('Using generic numbering labels...')\n                            labels = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()\n                except:\n                    print(\"Label reference file not found. Attempting AAL naming...\")\n                    if use_AAL_naming is True:\n                        try:\n                            labels = nodemaker.AAL_naming(coords)\n                        except:\n                            print('AAL reference labeling failed!')\n                            labels = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()\n                    else:\n                        print('Using generic numbering labels...')\n                        labels = np.arange(len(coords) + 1)[np.arange(len(coords) + 1) != 0].tolist()\n    else:\n        print('WARNING: No labels available since atlas name is not specified!')\n\n    print(\"%s%s\" % ('Labels:\\n', labels))\n    atlas_name = atlas\n    dir_path = utils.do_dir_path(atlas, in_file)\n\n    if len(coords) != len(labels):\n        labels = len(coords) * [np.nan]\n        if len(coords) != len(labels):\n            raise ValueError('ERROR: length of coordinates is not equal to length of label names')\n\n    return labels, coords, atlas_name, networks_list, parcel_list, par_max, uatlas, dir_path\n"
    ],
    [
        "in_file",
        [
            "/Users/derekpisner/Applications/PyNets/tests/examples/002/fmri/002_reor_RAS_nores2mm.nii.gz",
            "7a1739442cbbdefa0b3369edb8c0f5f5"
        ]
    ],
    [
        "parc",
        false
    ],
    [
        "ref_txt",
        null
    ],
    [
        "uatlas",
        null
    ],
    [
        "use_AAL_naming",
        false
    ]
]