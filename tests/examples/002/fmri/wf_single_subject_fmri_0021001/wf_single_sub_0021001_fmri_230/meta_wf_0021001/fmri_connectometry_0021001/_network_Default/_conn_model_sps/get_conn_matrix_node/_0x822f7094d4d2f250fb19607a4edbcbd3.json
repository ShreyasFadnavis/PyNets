[('ID', '0021001'), ('atlas', 'DesikanKlein2012'), ('binary', False), ('c_boot', 0), ('conn_model', 'sps'), ('coords', [('-40.0000000000', '32.0000000000', '-10.0000000000'), ('46.0000000000', '-66.0000000000', '30.0000000000'), ('52.0000000000', '-6.0000000000', '-8.0000000000'), ('-12.0000000000', '34.0000000000', '42.0000000000'), ('-36.0000000000', '12.0000000000', '48.0000000000'), ('42.0000000000', '34.0000000000', '-12.0000000000'), ('-50.0000000000', '-10.0000000000', '-6.0000000000'), ('10.0000000000', '-58.0000000000', '38.0000000000'), ('8.0000000000', '-44.0000000000', '20.0000000000'), ('48.0000000000', '32.0000000000', '4.0000000000'), ('6.0000000000', '-16.0000000000', '40.0000000000'), ('-6.0000000000', '-18.0000000000', '40.0000000000'), ('-46.0000000000', '14.0000000000', '12.0000000000'), ('-46.0000000000', '32.0000000000', '6.0000000000'), ('-8.0000000000', '-60.0000000000', '38.0000000000'), ('-22.0000000000', '-32.0000000000', '-18.0000000000'), ('-58.0000000000', '-28.0000000000', '-12.0000000000'), ('-42.0000000000', '-70.0000000000', '32.0000000000'), ('-6.0000000000', '40.0000000000', '6.0000000000'), ('58.0000000000', '-26.0000000000', '-12.0000000000'), ('6.0000000000', '38.0000000000', '2.0000000000'), ('-6.0000000000', '-46.0000000000', '20.0000000000'), ('6.0000000000', '38.0000000000', '-18.0000000000'), ('-6.0000000000', '42.0000000000', '-16.0000000000')]), ('dens_thresh', True), ('dir_path', '/Users/derekpisner/Applications/PyNets/tests/examples/002/fmri/DesikanKlein2012'), ('disp_filt', False), ('function_str', 'def get_conn_matrix(time_series, conn_model, dir_path, node_size, smooth, dens_thresh, network, ID, roi, min_span_tree,\n                    disp_filt, parc, prune, atlas, uatlas, labels, coords, c_boot, norm, binary,\n                    hpass):\n    """\n    Computes a functional connectivity matrix based on a node-extracted time-series array.\n    Includes a library of routines across Nilearn, scikit-learn, and skggm packages, among others.\n\n    Parameters\n    ----------\n    time_series : array\n        2D m x n array consisting of the time-series signal for each ROI node where m = number of scans and\n        n = number of ROI\'s.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s.\n    smooth : int\n        Smoothing width (mm fwhm) to apply to time-series when extracting signal from ROI\'s.\n    dens_thresh : bool\n        Indicates whether a target graph density is to be used as the basis for\n        thresholding.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    ID : str\n        A subject id or other unique identifier.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    min_span_tree : bool\n        Indicates whether local thresholding from the Minimum Spanning Tree\n        should be used.\n    disp_filt : bool\n        Indicates whether local thresholding using a disparity filter and\n        \'backbone network\' should be used.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to ROI nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    c_boot : int\n        Number of bootstraps if user specified circular-block bootstrapped resampling of the node-extracted time-series.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    hpass : bool\n        High-pass filter values (Hz) to apply to node-extracted time-series.\n\n    Returns\n    -------\n    conn_matrix : array\n        Adjacency matrix stored as an m x n array of nodes and edges.\n    conn_model : str\n       Connectivity estimation model (e.g. corr for correlation, cov for covariance, sps for precision covariance,\n       partcorr for partial correlation). sps type is used by default.\n    dir_path : str\n        Path to directory containing subject derivative data for given run.\n    node_size : int\n        Spherical centroid node size in the case that coordinate-based centroids\n        are used as ROI\'s for tracking.\n    smooth : int\n        Smoothing width (mm fwhm) to apply to time-series when extracting signal from ROI\'s.\n    dens_thresh : bool\n        Indicates whether a target graph density is to be used as the basis for\n        thresholding.\n    network : str\n        Resting-state network based on Yeo-7 and Yeo-17 naming (e.g. \'Default\') used to filter nodes in the study of\n        brain subgraphs.\n    ID : str\n        A subject id or other unique identifier.\n    roi : str\n        File path to binarized/boolean region-of-interest Nifti1Image file.\n    min_span_tree : bool\n        Indicates whether local thresholding from the Minimum Spanning Tree\n        should be used.\n    disp_filt : bool\n        Indicates whether local thresholding using a disparity filter and\n        \'backbone network\' should be used.\n    parc : bool\n        Indicates whether to use parcels instead of coordinates as ROI nodes.\n    prune : bool\n        Indicates whether to prune final graph of disconnected nodes/isolates.\n    atlas : str\n        Name of atlas parcellation used.\n    uatlas : str\n        File path to atlas parcellation Nifti1Image in MNI template space.\n    labels : list\n        List of string labels corresponding to graph nodes.\n    coords : list\n        List of (x, y, z) tuples corresponding to a coordinate atlas used or\n        which represent the center-of-mass of each parcellation node.\n    c_boot : int\n        Number of bootstraps if user specified circular-block bootstrapped resampling of the node-extracted time-series.\n    norm : int\n        Indicates method of normalizing resulting graph.\n    binary : bool\n        Indicates whether to binarize resulting graph edges to form an\n        unweighted graph.\n    hpass : bool\n        High-pass filter values (Hz) to apply to node-extracted time-series.\n    """\n    import warnings\n    warnings.filterwarnings("ignore")\n    from nilearn.connectome import ConnectivityMeasure\n    from sklearn.covariance import GraphicalLassoCV\n\n    conn_matrix = None\n    if conn_model == \'corr\' or conn_model == \'cor\' or conn_model == \'correlation\':\n        # credit: nilearn\n        print(\'\\nComputing correlation matrix...\\n\')\n        conn_measure = ConnectivityMeasure(kind=\'correlation\')\n        conn_matrix = conn_measure.fit_transform([time_series])[0]\n    elif conn_model == \'partcorr\' or conn_model == \'parcorr\' or conn_model == \'partialcorrelation\':\n        # credit: nilearn\n        print(\'\\nComputing partial correlation matrix...\\n\')\n        conn_measure = ConnectivityMeasure(kind=\'partial correlation\')\n        conn_matrix = conn_measure.fit_transform([time_series])[0]\n    elif conn_model == \'cov\' or conn_model == \'covariance\' or conn_model == \'covar\' or conn_model == \'sps\' or conn_model == \'sparse\' or conn_model == \'precision\':\n        # Fit estimator to matrix to get sparse matrix\n        estimator_shrunk = None\n        estimator = GraphicalLassoCV(cv=5)\n        try:\n            print(\'\\nComputing covariance...\\n\')\n            estimator.fit(time_series)\n        except:\n            print(\'Unstable Lasso estimation--Attempting to re-run by first applying shrinkage...\')\n            try:\n                from sklearn.covariance import GraphicalLasso, empirical_covariance, shrunk_covariance\n                emp_cov = empirical_covariance(time_series)\n                for i in np.arange(0.8, 0.99, 0.01):\n                    shrunk_cov = shrunk_covariance(emp_cov, shrinkage=i)\n                    alphaRange = 10.0 ** np.arange(-8, 0)\n                    for alpha in alphaRange:\n                        try:\n                            estimator_shrunk = GraphicalLasso(alpha)\n                            estimator_shrunk.fit(shrunk_cov)\n                            print("Retrying covariance matrix estimate with alpha=%s" % alpha)\n                            if estimator_shrunk is None:\n                                pass\n                            else:\n                                break\n                        except:\n                            print("Covariance estimation failed with shrinkage at alpha=%s" % alpha)\n                            continue\n            except ValueError:\n                print(\'Unstable Lasso estimation! Shrinkage failed. A different connectivity model may be needed.\')\n        if estimator is None and estimator_shrunk is None:\n            raise RuntimeError(\'\\nERROR: Covariance estimation failed.\')\n        if conn_model == \'sps\' or conn_model == \'sparse\' or conn_model == \'precision\':\n            if estimator_shrunk is None:\n                print(\'\\nFetching precision matrix from covariance estimator...\\n\')\n                conn_matrix = -estimator.precision_\n            else:\n                print(\'\\nFetching shrunk precision matrix from covariance estimator...\\n\')\n                conn_matrix = -estimator_shrunk.precision_\n        elif conn_model == \'cov\' or conn_model == \'covariance\' or conn_model == \'covar\':\n            if estimator_shrunk is None:\n                print(\'\\nFetching covariance matrix from covariance estimator...\\n\')\n                conn_matrix = estimator.covariance_\n            else:\n                conn_matrix = estimator_shrunk.covariance_\n    elif conn_model == \'QuicGraphicalLasso\':\n        try:\n            from inverse_covariance import QuicGraphicalLasso\n        except ImportError:\n            print(\'Cannot run QuicGraphLasso. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLasso\n        # credit: skggm\n        model = QuicGraphicalLasso(\n            init_method=\'cov\',\n            lam=0.5,\n            mode=\'default\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLasso precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'QuicGraphLassoCV\':\n        try:\n            from inverse_covariance import QuicGraphicalLassoCV\n        except ImportError:\n            print(\'Cannot run QuicGraphLassoCV. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLassoCV\n        # credit: skggm\n        model = QuicGraphicalLassoCV(\n            init_method=\'cov\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLassoCV precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'QuicGraphicalLassoEBIC\':\n        try:\n            from inverse_covariance import QuicGraphicalLassoEBIC\n        except ImportError:\n            print(\'Cannot run QuicGraphLassoEBIC. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via QuicGraphLassoEBIC\n        # credit: skggm\n        model = QuicGraphicalLassoEBIC(\n            init_method=\'cov\',\n            verbose=1)\n        print(\'\\nCalculating QuicGraphLassoEBIC precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.precision_\n    elif conn_model == \'AdaptiveQuicGraphLasso\':\n        try:\n            from inverse_covariance import AdaptiveQuicGraphicalLasso, QuicGraphicalLassoEBIC\n        except ImportError:\n            print(\'Cannot run AdaptiveGraphLasso. Skggm not installed!\')\n\n        # Compute the sparse inverse covariance via\n        # AdaptiveGraphLasso + QuicGraphLassoEBIC + method=\'binary\'\n        # credit: skggm\n        model = AdaptiveQuicGraphicalLasso(\n            estimator=QuicGraphicalLassoEBIC(\n                init_method=\'cov\',\n            ),\n            method=\'binary\',\n        )\n        print(\'\\nCalculating AdaptiveQuicGraphLasso precision matrix using skggm...\\n\')\n        model.fit(time_series)\n        conn_matrix = -model.estimator_.precision_\n    else:\n        raise ValueError(\'\\nERROR! No connectivity model specified at runtime. Select a valid estimator using the \'\n                         \'-mod flag.\')\n\n    if conn_matrix.shape < (2, 2):\n        raise RuntimeError(\'\\nERROR! Matrix estimation selection yielded an empty or 1-dimensional graph. \'\n                           \'Check time-series for errors or try using a different atlas\')\n\n    coords = np.array(coords)\n    labels = np.array(labels)\n    return conn_matrix, conn_model, dir_path, node_size, smooth, dens_thresh, network, ID, roi, min_span_tree, disp_filt, parc, prune, atlas, uatlas, labels, coords, c_boot, norm, binary, hpass\n'), ('hpass', None), ('labels', ['nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan', 'nan']), ('min_span_tree', False), ('network', 'Default'), ('node_size', 4), ('norm', 0), ('parc', False), ('prune', '1'), ('roi', None), ('smooth', 0), ('time_series', array([[ 1.3127716 ,  1.1574162 ,  1.4838659 , ...,  0.67249227,
        -0.50939476, -0.8282963 ],
       [-0.77208716, -0.22721355, -0.05433574, ...,  0.80564415,
         0.7557712 ,  0.24824011],
       [ 0.7586903 , -1.3740423 , -0.9933575 , ...,  0.07429074,
        -0.32368442, -1.6436886 ],
       ...,
       [ 0.8830816 ,  0.68389726, -0.02967551, ...,  0.44515112,
         0.86113846,  0.32610065],
       [ 0.8627658 ,  1.8771849 ,  1.1543678 , ...,  1.9672911 ,
         0.56556803,  0.17502418],
       [ 0.11045323, -0.01386644,  0.0496253 , ...,  2.1081576 ,
        -0.87343735, -0.60447407]], dtype=float32)), ('uatlas', ('/Users/derekpisner/Applications/PyNets/pynets/atlases/DesikanKlein2012.nii.gz', '8b05327694ff8612e04249dae9d49822'))]